searchState.loadedDescShard("hlsl_lang_pp", 0, "Last preprocessing stage definitions\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n+=\n&amp;\n&amp;=\n&amp;&amp;\n\\\n!\n|\n^\n:\n,\nComment (single-line or multi-line)\n–\ndefined preprocessor keyword\nDigit sequence\n/=\n=\n==\nInvalid token\n=\nIdentifier or keyword\n++\n&lt;\n{\n[\n&lt;&lt;=\n&lt;&lt;\n&lt;=\nLine continuation (required for tracking exact offsets)\n(\nFinal stage lexer.\n%=\n*=\nNewline\n!=\n|=\n||\n%\n.\n?\n“string”\n}\n]\n=\n)\n;\n/\n-=\n~\nWhitespace\n^=\n^^\nUnglued token buffer. Since we’re pasting at most 3 …\nReturns the argument unchanged.\nReturns the argument unchanged.\nLast stage lexer declaration\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFirst stage lexer declaration\nSecond stage lexer declaration\nFinal stage lexer.\nUnglued token buffer. Since we’re pasting at most 3 …\nGet a reference to the input slice\nConsume this lexer and return the line map\nGet a reference to the line map\nNotify the lexer we are parsing an #include directive, and …\n+=\n&amp;\n&amp;=\n&amp;&amp;\n\\\n!\n|\n^\n:\n,\nComment (single-line or multi-line)\n–\ndefined preprocessor keyword\nDigit sequence\n/=\n=\n==\nInvalid token\n=\nIdentifier or keyword\n++\n&lt;\n{\n[\n&lt;&lt;=\n&lt;&lt;\n&lt;=\nLine continuation (required for tracking exact offsets)\n(\n%=\n*=\nNewline\n!=\n|=\n||\n%\n.\n?\n“string”\n}\n]\n=\n)\n;\n/\n-=\n~\nWhitespace\n^=\n^^\nBasic lexer to split input lines according to the GLSL spec\nFirst stage token with location\nType of token for line splitting\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInsite an angle string\nLine continuation character seen\nBuilding a digit sequence\nBuilding an identifier\nInitial state of the preprocessor\nMulti-line comment\nMulti-line comment, saw a *\nA lexer for early lexical analysis stages.\nInside a quote string\nSingle-line comment\nPossibly a start of comment\nAny kind of horizontal whitespace\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n&amp;\n\\\n!\n|\n^\n:\n,\nComment (single-line or multi-line)\ndefined preprocessor keyword\nDigit sequence\n=\nInvalid token\nIdentifier or keyword\n&lt;\n{\n[\nLine continuation (required for tracking exact offsets)\n(\nNewline\n%\n.\n?\n“string”\n}\n]\n)\n;\n/\n~\nWhitespace\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n+=\n&amp;\n&amp;=\n&amp;&amp;\n\\\n!\n|\n^\n:\n,\nComment (single-line or multi-line)\n–\ndefined preprocessor keyword\nDigit sequence\n/=\n=\n==\nInvalid token\n=\nIdentifier or keyword\n++\n&lt;\n{\n[\n&lt;&lt;=\n&lt;&lt;\n&lt;=\nLine continuation (required for tracking exact offsets)\n(\n%=\n*=\nNewline\n!=\n|=\n||\n%\n.\n?\n“string”\n}\n]\n=\n)\n;\n/\n-=\n~\nWhitespace\n^=\n^^\nParse a control line\n+=\n&amp;\n&amp;=\n&amp;&amp;\n\\\n!\n|\n^\n:\n,\nComment (single-line or multi-line)\n–\ndefined preprocessor keyword\nDigit sequence\n/=\n=\n==\nInvalid token\n=\nIdentifier or keyword\n++\n&lt;\n{\n[\n&lt;&lt;=\n&lt;&lt;\n&lt;=\n(\n%=\n*=\nNewline\n!=\n|=\n||\n%\n.\nConcatenation expression\n#define\n#elif\n#else\n#endif\n#error\n#error body\n#extension\n#if\n#ifdef\n#ifndef\n#include\n#include path\n#line\n#line body\n#pragma\n#pragma body\n#undef\n#version\n?\n“string”\n}\n]\n=\nAST root\n)\n;\n/\n-=\n~\nWhitespace\n^=\n^^\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGL_ARB_shading_language_include runtime includes\nGL_GOOGLE_include_directive compile-time includes\nOperating mode for #include directives\nNo #include directives are allowed\nCurrent state of the preprocessor\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe current #if group of this level is included\nNo #if group of this level was included\nOne past #if group of this level was included, but not the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPreprocessor based on a filesystem\nMapping from #include/input paths to canonical paths\nMapping from #include/input paths to canonical paths\nCache of parsed files (preprocessor token sequences)\nCache of parsed files (preprocessor token sequences)\nMapping from canonical paths to FileIds\nMapping from canonical paths to FileIds\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFilesystem abstraction\nFilesystem abstraction\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nParse a given source block as if it belonged in a specific …\nList of include paths in resolution order\nList of include paths in resolution order\nAll extensions\nA preprocessor definition\nContains the error value\nExtension behavior\nExtension name\nContains the success value\nSpecific extension\nReturns an integer representing the relative size of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nType of this definition\nName of this definition\ntrue if this definition can’t be #undef-ined\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n“active”\n+=\n&amp;\n&amp;=\n&amp;&amp;\n“asm”\n“attribute”\n!\n|\n“bool”\nBool constant\n“break”\n“bool2” (HLSL vector type)\n“bool3” (HLSL vector type)\n“bool4” (HLSL vector type)\n^\n“case”\n“cast”\n“cbuffer”\n“centroid”\n“class”\n“coherent”\n:\n,\nComment (single-line or multi-line)\n“common”\n“const”\n“continue”\n–\n“default”\n“discard”\n/=\n“do”\n“double”\nDouble constant\n“else”\n“enum”\n=\n==\nMarker for invalid tokens\n“extern”\n“external”\n“filter”\n“fixed”\n“flat”\n“float”\nFloat constant\n“for”\n=\n“goto”\n“groupshared” (HLSL)\n“half”\n“highp”\nIdentifier\n“if”\n“in”\n++\n“inline”\n“inout”\n“int”\n“interface”\nInt constant\n“invariant”\n“int2” (HLSL vector type)\n“int3” (HLSL vector type)\n“int4” (HLSL vector type)\n&lt;\n“layout”\n{\n[\n&lt;&lt;=\n&lt;&lt;\n&lt;=\n“long”\n“lowp”\n(\n“float1x1” through “float4x4” (HLSL matrix types)\n“float1x2” (HLSL matrix type)\n“float1x3” (HLSL matrix type)\n“float1x4” (HLSL matrix type)\n“float2x2” (HLSL matrix type)\n“float2x1” (HLSL matrix type)\n“float2x2” (HLSL matrix type)\n“float2x3” (HLSL matrix type)\n“float2x4” (HLSL matrix type)\n“float3x3” (HLSL matrix type)\n“float3x1” (HLSL matrix type)\n“float3x2” (HLSL matrix type)\n“float3x3” (HLSL matrix type)\n“float3x4” (HLSL matrix type)\n“float4x4” (HLSL matrix type)\n“float4x1” (HLSL matrix type)\n“float4x2” (HLSL matrix type)\n“float4x3” (HLSL matrix type)\n“float4x4” (HLSL matrix type)\n“matrix” (HLSL matrix type, equivalent to float4x4)\n“mediump”\n%=\n*=\n“namespace”\n!=\n“noinline”\n“noperspective”\n|=\n||\nGeneric type name\n“out”\n“output”\n“packoffset”\n“partition”\n“patch”\n%\n.\n“precise”\n“precision”\n“public”\n?\n}\n]\n“readonly”\n“register”\nReserved for future use\n“resource”\n“restrict”\n“return”\n=\n)\n“RWStructuredBuffer” (HLSL buffer type)\n“sample”\n“sampler” (HLSL sampler type)\n“SamplerComparisonState”\n“SamplerState”\n;\n“shared”\n“short”\n“sizeof”\n/\n“smooth”\n“static”\nString constant\n“struct”\n“StructuredBuffer” (HLSL buffer type)\n“subroutine”\n-=\n“superp”\n“switch”\n“template”\n“Texture1D” (HLSL texture type)\n“Texture1DArray” (HLSL texture type)\n“Texture2D” (HLSL texture type)\n“Texture2DArray” (HLSL texture type)\n“Texture2DMS” (HLSL texture type)\n“Texture2DMSArray” (HLSL texture type)\n“Texture2DRect” (HLSL texture type)\n“Texture3D” (HLSL texture type)\n“TextureBuffer” (HLSL texture type)\n“TextureCube” (HLSL texture type)\n“TextureCubeArray” (HLSL texture type)\n“this”\n~\n“typedef”\nType name\n“uint”\nUnsigned int constant\n“uniform”\n“union”\n“unsigned”\n“using”\n“uint2” (HLSL vector type)\n“uint3” (HLSL vector type)\n“uint4” (HLSL vector type)\n“varying”\n“float2” (HLSL vector type)\n“float3” (HLSL vector type)\n“float4” (HLSL vector type)\n“void”\n“volatile”\n“while”\n“writeonly”\nWhitespaace\n^=\n^^\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdd a new line boundary\nReturns the argument unchanged.\nSplit an offset into line and column information\nCalls <code>U::from(self)</code>.\nConstruct a new, empty LineMap\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")